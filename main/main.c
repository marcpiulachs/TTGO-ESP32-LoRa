#include <nvs_flash.h>
#include <nvs.h>
#include <string.h>
#include <driver/gpio.h>
#include <esp_log.h>
#include <esp_pm.h>

#include "wifi.h"
#include "wifi_access_point.h"
#include "wifi_client.h"
#include "http.h"
#include "mqtt_connection.h"
#include "die_sensors.h"
#include "datetime.h"
#include "audio.h"
#include "button.h"
#include "sounds.h"
#include "valve.h"

static const gpio_num_t BUTTON_SETUP = GPIO_NUM_33;

static const char *TAG = "Main";

void app_main(void) 
{
	esp_err_t espError;

	ESP_LOGW(TAG, "Starting up device....");
    ESP_LOGI(TAG, "Free memory: %d bytes", esp_get_free_heap_size());
    ESP_LOGI(TAG, "IDF version: %s", esp_get_idf_version());

    //Initialize NVS
	espError = nvs_flash_init();

    if (espError == ESP_ERR_NVS_NO_FREE_PAGES) {
		ESP_ERROR_CHECK(nvs_flash_erase());
      	ESP_ERROR_CHECK(nvs_flash_init());
	}

	// Set device unique ID
    nvs_handle nvsHandle;
	ESP_ERROR_CHECK(nvs_open("BeelineNVS", NVS_READWRITE, &nvsHandle));

	char deviceName[16] = {0};
	size_t nvsLength = sizeof(deviceName);
	espError = nvs_get_str(nvsHandle, "uniqueName", deviceName, &nvsLength);

	if (espError == ESP_ERR_NVS_NOT_FOUND)
	{
		uint8_t baseMac[6];

		// Get MAC address for WiFi station
		esp_read_mac(baseMac, ESP_MAC_WIFI_STA);

		// Write unique name into apName
		sprintf(deviceName, "S-%02X%02X%02X%02X%02X%02X",
				baseMac[0],
				baseMac[1],
				baseMac[2],
				baseMac[3],
				baseMac[4],
				baseMac[5]);

		ESP_LOGW(TAG, "Unique device name generated by MAC address");

		ESP_ERROR_CHECK(nvs_set_str(nvsHandle, "uniqueName", deviceName));
		ESP_ERROR_CHECK(nvs_commit(nvsHandle));

		nvs_close(nvsHandle);
	}

	ESP_LOGW(TAG, "Device name: %s", deviceName);
	
	// Setup config button
	gpio_config_t io_conf;
    io_conf.intr_type = GPIO_PIN_INTR_DISABLE;
    io_conf.mode = GPIO_MODE_INPUT;
    io_conf.pin_bit_mask = (1ULL << BUTTON_SETUP);
    io_conf.pull_down_en = GPIO_PULLUP_ENABLE;
    io_conf.pull_up_en = GPIO_PULLDOWN_DISABLE;
    gpio_config(&io_conf);

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    ESP_LOGW(TAG, "Hold [SETUP] for config mode.");

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    int configMode = gpio_get_level(BUTTON_SETUP);

    if (configMode)
	{
    	ESP_LOGW(TAG, "Starting in config mode. Reseting all values to factory defaults.");

    	// Reset all NVS data so we always get known values and don't crash
    	wifi_reset_nvs();
    	wifi_client_reset_nvs();
    	mqtt_conn_reset_nvs();
    	datetime_reset_nvs();
    	dieSensorsResetNVS();

		/* Starting up as a configuration AP */
    	wifi_ap_init();
    }
    else
	{
    	ESP_LOGW(TAG, "Starting in normal mode.");
    
		/* Starting up as a network client device */
		wifi_client_init();
    }
	
    #if CONFIG_PM_ENABLE
	    // Configure dynamic frequency scaling:
	    // maximum and minimum frequencies are set in sdkconfig,
	    // automatic light sleep is enabled if tickless idle support is enabled.
	    esp_pm_config_esp32_t pm_config = {
	            .max_freq_mhz = CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ,
	            .min_freq_mhz = CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ,
		#if CONFIG_FREERTOS_USE_TICKLESS_IDLE
	            .light_sleep_enable = true
		#endif
    	};
    	ESP_ERROR_CHECK( esp_pm_configure(&pm_config) );
	#endif // CONFIG_PM_ENABLE

	button_init();
	valve_init();
    datetime_init();
    httpd_init();
    mqtt_conn_init();
    dieSensorsInit();
	audio_init();                                                  

/*
	while(true)
	{
		audioPlay(dat, sizeof(dat));
		vTaskDelay(5000 / portTICK_PERIOD_MS);
	}*/
}

